import fs from "fs";
import {getBooleanInput, getInput} from "@actions/core";
import {context} from "@actions/github";
import {Octokit} from "@octokit/action";
import {
    createBranchIfNotExists,
    createOrUpdateFile,
    createPRComment,
    getFile,
    getRepoName,
    getRepoOwner,
    getSourceBranch,
    isPullRequest,
    updateComment
} from "./github";
import {exec, getExecOutput} from "@actions/exec";
import {
    downloadCodeLimitBinary,
    getReportContent,
    installCodeLimit,
    makeNotFoundBadgeSvg,
    makeStatusBadgeSvg
} from "./codelimit";
import {getChangedFiles} from "./utils";
import {version} from "./version";
import signale, {error, info, success} from "signale";

signale.config({
    displayTimestamp: true
});

async function generateMarkdownReport(reportMarkdown: string, findingsMarkdown: string) {
    let result = '';
    result += '## CodeLimit Report\n';
    result += '\n';
    result += reportMarkdown;
    result += '### Findings\n';
    result += findingsMarkdown;
    result += '\n';
    result += 'Generated by [CodeLimit](https://getcodelimit.github.io)\n';
    return result;
}

async function updateReportsBranch(octokit: Octokit, owner: string, repo: string, branch: string, markdown: string) {
    await createBranchIfNotExists(octokit, owner, repo, '_codelimit_reports');
    const reportContent = getReportContent();
    let badgeContent;
    if (reportContent) {
        const reportJson = JSON.parse(reportContent);
        badgeContent = makeStatusBadgeSvg(reportJson.codebase);
    } else {
        badgeContent = makeNotFoundBadgeSvg();
    }
    await createOrUpdateFile(octokit, owner, repo, '_codelimit_reports', `${branch}/badge.svg`, badgeContent);
    success(`Updated badge in branch _codelimit_reports/${branch}`);
    if (reportContent) {
        await createOrUpdateFile(octokit, owner, repo, '_codelimit_reports', `${branch}/report.json`, reportContent);
        success(`Updated JSON report in branch _codelimit_reports/${branch}`);
    }
    await createOrUpdateFile(octokit, owner, repo, '_codelimit_reports', `${branch}/codelimit.md`, markdown);
    success(`Updated markdown report in branch _codelimit_reports/${branch}`);
}

async function updatePullRequestComment(octokit: Octokit, owner: string, repo: string, branch: string, markdownReport: string) {
    const prNumber = context.payload.pull_request?.number;
    if (prNumber) {
        const actionStateFile = await getFile(octokit, owner, repo, '_codelimit_reports', `${branch}/action.json`);
        if (actionStateFile) {
            const fileContent = Buffer.from(actionStateFile.content, 'base64').toString('utf-8');
            const actionState = JSON.parse(fileContent) as ActionState;
            const commentId = actionState.commentId;
            info(`Updating existing comment with ID: ${commentId}`);
            await updateComment(octokit, owner, repo, prNumber, markdownReport, commentId);
        } else {
            info('State file not found, creating new comment');
            const commentId = await createPRComment(octokit, owner, repo, prNumber, markdownReport);
            const actionState: ActionState = {commentId: commentId};
            const actionStateJson = JSON.stringify(actionState);
            await createOrUpdateFile(octokit, owner, repo, '_codelimit_reports', `${branch}/action.json`, actionStateJson);
        }
    }
}

async function checkChangedFiles(octokit: Octokit, clBinary: string): Promise<number> {
    const changedFiles = await getChangedFiles(octokit);
    info(`Number of files changed: ${changedFiles.length}`);
    if (changedFiles.length === 0) {
        info('No files changed, skipping CodeLimit');
        return 0;
    } else {
        info('Running CodeLimit...');
        return await exec(clBinary, ['check'].concat(changedFiles), {ignoreReturnCode: true});
    }
}

async function updateRepository(octokit: Octokit, clBinary: string) {
    const reportMarkdown = (await getExecOutput(clBinary, ['report', '--format', 'markdown'])).stdout;
    const findingsMarkdown = (await getExecOutput(clBinary, ['findings', '--format', 'markdown'])).stdout;
    const findingsFullMarkdown = (await getExecOutput(clBinary, ['findings', '--full', '--format', 'markdown'])).stdout;
    const markdownReport = await generateMarkdownReport(reportMarkdown, findingsMarkdown);
    const markdownFullFindingsReport = await generateMarkdownReport(reportMarkdown, findingsFullMarkdown);
    const owner = getRepoOwner(context);
    const repo = getRepoName(context);
    const branch = getSourceBranch();
    if (!owner || !repo || !branch) {
        error('Could not determine repository owner, name, or branch');
        process.exit(1);
    }
    try {
        await updateReportsBranch(octokit, owner, repo, branch, markdownFullFindingsReport);
    } catch (e: unknown) {
        error('Failed to update reports branch');
        if (e instanceof Error) {
            error(`Reason: ${e.message}`);
        }
    }
    if (isPullRequest()) {
        try {
            await updatePullRequestComment(octokit, owner, repo, branch, markdownReport);
        } catch (e: unknown) {
            error('Failed to update pull request comment');
            if (e instanceof Error) {
                error(`Reason: ${e.message}`);
            }
        }
    }
}

async function main() {
    info(`CodeLimit-action, version: ${version.revision}`);
    const codeLimitVersion = getInput('codelimit_version') || 'latest';
    info(`CodeLimit version requested: ${codeLimitVersion}`);
    let clBinary;
    if (codeLimitVersion === 'latest') {
        clBinary = await downloadCodeLimitBinary();
    } else {
        clBinary = await installCodeLimit();
    }
    info(`CodeLimit binary: ${clBinary}`);
    info('CodeLimit version:');
    await exec(clBinary, ['--version']);
    info('Scanning codebase...');
    await exec(clBinary, ['scan', '.']);
    const octokit = new Octokit({auth: getInput('token')});
    const doCheck = getBooleanInput('check');
    let exitCode = 0;
    if (doCheck) {
        exitCode = await checkChangedFiles(octokit, clBinary);
    }
    await updateRepository(octokit, clBinary);
    fs.unlinkSync(clBinary);
    success('Done!');
    process.exit(exitCode);
}

main();
